#!/bin/sh

# Colors for prompt
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

show_help() {
    echo "Usage:"
    echo "  bcguard --crypt file1 [file2 ...]"
    echo "  bcguard --crypt -u recipient file1 [file2 ...]"
    echo "  bcguard --crypt -k mapping_code file1 [file2 ...]"
    echo "  bcguard --crypt -u recipient -k mapping_code file1 [file2 ...]"
    echo "  bcguard --decrypt input.bcg"
    echo "  bcguard --decrypt -o directory input.bcg"
    echo "  bcguard --generate-mapping"
    echo ""
    echo "Options:"
    echo "  --crypt, -c            Encrypt files"
    echo "  --decrypt, -d          Decrypt file"
    echo "  --user-recipient, -u   Specify GPG recipient"
    echo "  --key-map, -k          Specify mapping code"
    echo "  --output, -o           Output directory for decryption"
    echo "  --generate-mapping, -g Generate new mapping and update config"
    echo "  --help, -h             Show this help"
    echo ""
    echo "Configuration:"
    echo "  Create ~/.bcguard with:"
    echo "    mapping=YOUR_MAPPING_CODE"
    echo "    recipient=YOUR_GPG_RECIPIENT"
}

# Load config from file
load_config() {
    if [ -f ~/.bcguard ]; then
        while IFS='=' read -r key value; do
            case "$key" in
                mapping) BCGUARD_MAPPING="$value" ;;
                recipient) BCGUARD_RECIPIENT="$value" ;;
            esac
        done < ~/.bcguard
    fi
}

# Initialize config
load_config

# Function to generate random mapping
generate_mapping() {
    # Базовый набор символов (A-P)
    base_chars="ABCDEFGHIJKLMNOP"
    result=""

    # Создаем массив из символов
    i=1
    while [ $i -le 16 ]; do
        char=$(echo "$base_chars" | cut -c $i)
        result="$result$char"
        i=$((i + 1))
    done

    # Перемешиваем с помощью /dev/urandom
    shuffled=""
    remaining="$result"

    while [ -n "$remaining" ]; do
        # Получаем случайное число от 0 до длины remaining
        rand_hex=$(dd if=/dev/urandom bs=1 count=1 2>/dev/null | hexdump -e '1/1 "%u"')
        length=$(echo -n "$remaining" | wc -c)
        pos=$((rand_hex % length + 1))

        # Извлекаем символ на позиции pos
        char=$(echo "$remaining" | cut -c $pos)
        shuffled="$shuffled$char"

        # Удаляем этот символ из remaining
        if [ $pos -eq 1 ]; then
            remaining=$(echo "$remaining" | cut -c 2-)
        elif [ $pos -eq $length ]; then
            remaining=$(echo "$remaining" | cut -c 1-$((length - 1)))
        else
            front=$(echo "$remaining" | cut -c 1-$((pos - 1)))
            back=$(echo "$remaining" | cut -c $((pos + 1))-)
            remaining="${front}${back}"
        fi
    done

    echo "$shuffled"
}

# Function to generate and save mapping
generate_mapping_command() {
    echo "Start generating your unique mapping"
    echo "============================================"

    echo "Generate..."
    mapping=$(generate_mapping)

    sleep 1

    echo ""
    echo "Done! Generation completed successfully!"
    echo -e "${NC}Your mapping: ${GREEN}$mapping${NC}"
    echo ""

    # Show existing gpg keys
    echo "Available GPG keys for use:"
    echo "---------------------"
    gpg -k 2>/dev/null | grep -E "^(pub|uid)" | while read -r line; do
        if echo "$line" | grep -q "^pub"; then
            echo "$line"
        else
            echo "  $line"
        fi
    done
    echo ""

    # Спрашиваем, нужно ли обновить конфиг
    printf "Save generated mapping to your config at ~/.bcguard? [Y/n]: "
    read -r save_config
    
    if [ "$save_config" = "n" ] || [ "$save_config" = "N" ]; then
        echo ""
        echo "Successfully!"
        echo "=============================="
        return 0
    fi

    # Обновляем конфиг
    echo "mapping=$mapping" > ~/.bcguard
    
    # Спрашиваем про получателя
    printf "Do you want to specify the default GPG recipient in the config? [Y/n]: "
    read -r set_recipient
    
    if [ "$set_recipient" != "n" ] && [ "$set_recipient" != "N" ]; then
        printf "Choose recipient of gpg (email or ID): "
        read -r recipient
        if [ -n "$recipient" ]; then
            echo "recipient=$recipient" >> ~/.bcguard
            echo "The recipient '$recipient' has been successfully added to configuration."
        fi
    else
        echo "The recipient is not specified. You can specify it during encryption using the -u flag."
    fi

    echo ""
    echo "Configuration updated successfully!"
    echo ""
    echo "Now you can use bcguard commands:"
    echo "  bcguard -c file.txt                    # for encryption"
    echo "  bcguard -c -u recipient file.txt       # if a different recipient is needed"
    echo "  bcguard -d file.txt.bcg                # for decryption"
    echo ""
    echo ""
    echo ""
    echo -e "${RED}!!!Warning!!!${NC}"
    echo ""
    echo -e "${RED}Be careful! Save a backup copy of your mapping in a safe place! Your mapping is your key to decrypting your files${NC}"
    echo ""
    echo ""
    echo ""

}

generate_output_name() {
    local first_file="$1"
    local file_count="$2"
    
    if [ "$file_count" -eq 1 ]; then
        echo "${first_file}.bcg"
    else
        base_name="secure"
        counter=1
        output_file="${base_name}.bcg"
        
        while [ -f "$output_file" ]; do
            output_file="${base_name}_${counter}.bcg"
            counter=$((counter + 1))
        done
        
        echo "$output_file"
    fi
}

# Function to check for existing files before extraction
check_existing_files() {
    local input_file="$1"
    local mapping="$2"
    local output_dir="$3"
    
    # Get list of files in the archive
    local file_list=$(cat "$input_file" | tr "$mapping" '0123456789abcdef' | xxd -p -r | gpg -d 2>/dev/null | tar -tzf - 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        return 1
    fi
    
    local existing_files=""
    for file in $file_list; do
        # Skip directories
        if [ "${file: -1}" != "/" ] && [ -f "$output_dir/$file" ]; then
            existing_files="$existing_files$file\n"
        fi
    done
    
    if [ -n "$existing_files" ]; then
        echo "Warning: The following files already exist and will be overwritten:"
        printf "$existing_files"
        printf "Continue? [y/N]: "
        read -r confirm
        if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
            echo "Operation cancelled"
            return 1
        fi
    fi
    
    return 0
}

encrypt_files() {
    output_file=""
    recipient=""
    mapping=""
    files=""
    
    # Parse all options first
    while [ $# -gt 0 ]; do
        case "$1" in
            -u|--user-recipient)
                if [ -n "$2" ]; then
                    recipient="$2"
                    shift 2
                else
                    echo "Error: Missing argument for -u/--user-recipient"
                    exit 1
                fi
                ;;
            -k|--key-map)
                if [ -n "$2" ]; then
                    mapping="$2"
                    shift 2
                else
                    echo "Error: Missing argument for -k/--key-map"
                    exit 1
                fi
                ;;
            *)
                # Skip empty arguments
                if [ -n "$1" ]; then
                    files="$files $1"
                fi
                shift
                ;;
        esac
    done
    
    # Remove leading space
    files=$(echo "$files" | sed 's/^ *//')
    
    if [ -z "$files" ]; then
        echo "Error: No files specified for encryption"
        exit 1
    fi
    
    # Check if files exist
    for file in $files; do
        if [ ! -f "$file" ] && [ ! -d "$file" ]; then
            echo "Error: File or directory '$file' not found"
            exit 1
        fi
    done
    
    # Get first file for output naming
    first_file=$(echo "$files" | awk '{print $1}')
    file_count=$(echo "$files" | wc -w)
    
    # Generate output filename
    output_file=$(generate_output_name "$first_file" "$file_count")
    
    # Check if output file already exists
    if [ -f "$output_file" ]; then
        printf "Output file '$output_file' already exists. Overwrite? [y/N]: "
        read -r overwrite
        if [ "$overwrite" != "y" ] && [ "$overwrite" != "Y" ]; then
            echo "Operation cancelled"
            exit 1
        fi
    fi
    
    # Get mapping code if not provided via -k
    if [ -z "$mapping" ]; then
        mapping="$BCGUARD_MAPPING"
        if [ -z "$mapping" ]; then
            echo "Error: Mapping code not specified."
            echo "Use -k flag, set BCGUARD_MAPPING variable, or create ~/.bcguard file"
            exit 1
        fi
    fi
    
    # Get recipient if not provided via -u
    if [ -z "$recipient" ]; then
        recipient="$BCGUARD_RECIPIENT"
    fi
    
    echo "Encrypting to: $output_file"
    
    # Build command based on whether recipient was provided
    if [ -n "$recipient" ]; then
        tar -czf - $files | gpg -ear "$recipient" | xxd -p | tr '0123456789abcdef' "$mapping" > "$output_file"
    else
        tar -czf - $files | gpg -ea | xxd -p | tr '0123456789abcdef' "$mapping" > "$output_file"
    fi
    
    if [ $? -eq 0 ]; then
        echo "Successfully encrypted to $output_file"
    else
        echo "Error: Encryption failed"
        rm -f "$output_file"
        exit 1
    fi
}

decrypt_file() {
    output_dir=""
    input_file=""
    
    # Parse options
    while [ $# -gt 0 ]; do
        case "$1" in
            -o|--output)
                if [ -n "$2" ]; then
                    output_dir="$2"
                    shift 2
                else
                    echo "Error: Missing argument for -o/--output"
                    exit 1
                fi
                ;;
            *)
                # Skip empty arguments
                if [ -n "$1" ]; then
                    input_file="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [ -z "$input_file" ]; then
        echo "Error: No input file specified"
        exit 1
    fi
    
    if [ ! -f "$input_file" ]; then
        echo "Error: File '$input_file' not found"
        exit 1
    fi
    
    # Set output directory
    if [ -n "$output_dir" ]; then
        if [ -f "$output_dir" ]; then
            echo "Error: '$output_dir' is a file, not a directory"
            exit 1
        fi
        # Create directory if it doesn't exist
        mkdir -p "$output_dir"
    else
        output_dir="."  # текущая директория
    fi
    
    printf "Enter mapping code: "
    read -r mapping

    # Check for existing files before extraction
    if ! check_existing_files "$input_file" "$mapping" "$output_dir"; then
        exit 1
    fi

    # Perform decryption and extraction
    echo "Decrypting..."
    if [ "$output_dir" = "." ]; then
        cat "$input_file" | tr "$mapping" '0123456789abcdef' | xxd -p -r | gpg -d | tar -xzf -
    else
        cat "$input_file" | tr "$mapping" '0123456789abcdef' | xxd -p -r | gpg -d | tar -xzf - -C "$output_dir"
    fi
    
    if [ $? -eq 0 ]; then
        echo "Successfully decrypted to $output_dir"
    else
        echo "Error: Decryption failed"
        exit 1
    fi
}

# Parse arguments - handle empty case
if [ $# -eq 0 ]; then
    echo "Error: No arguments provided"
    echo "Use 'bcguard --help' for usage information"
    exit 1
fi

case "$1" in
    --crypt|-c)
        shift
        encrypt_files "$@"
        ;;
    --decrypt|-d)
        shift
        decrypt_file "$@"
        ;;
    --generate-mapping|-g)
        generate_mapping_command
        ;;
    --help|-h)
        show_help
        ;;
    *)
        if [ -n "$1" ]; then
            echo "Error: Unknown option '$1'"
        else
            echo "Error: Invalid empty option"
        fi
        echo "Use 'bcguard --help' for usage information"
        exit 1
        ;;
esac
